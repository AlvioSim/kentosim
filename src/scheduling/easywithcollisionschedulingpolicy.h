#ifndef SIMULATOREASYWITHCOLLISIONSCHEDULINGPOLICY_H
#define SIMULATOREASYWITHCOLLISIONSCHEDULINGPOLICY_H

#include <scheduling/easyschedulingpolicy.h>
#include <scheduling/virtualanalogicalrtable.h>

namespace Simulator {

/**
* @author Francesc Guim,C6-E201,93 401 16 50, <fguim@pcmas.ac.upc.edu>*/

/** 
* This function implements the EASYSchedulingPolicy , but takes into account the collisions between the jobs when they are allocated.
* @see For more information see the virtualanalogicalrtable class. 
*/
class EASYWithCollisionSchedulingPolicy : public EASYSchedulingPolicy{
public:
  EASYWithCollisionSchedulingPolicy();
  EASYWithCollisionSchedulingPolicy(ArchitectureConfiguration* theValue,Log* log,double globaltime,Backfilling_variant_t backfillingType);
  virtual ~EASYWithCollisionSchedulingPolicy();
    
  /* iherited functions from the EASY SchedulingPolicy class  - we only will modify those functions that take part in the decision 
     of where to submitt the job */  
  virtual void setJobList(map< int, Job * >* theValue); //this is redifined due to we need to set the list of jobs to the reservation table.
  virtual void jobRemoveFromRT(Job* job); //this is redifined due to the job may be killed depending on the penalty of its real runtime 
  void setThresshold ( double theValue );
  double getthresshold() const;
  bool canSatisfyThresholdRestriction(Job* job,double thresshold);
  void setAlternativeThreshold ( double theValue );
  double getalternativeThreshold() const;
  	
	
     
protected:     
  virtual AnalogicalJobAllocation* findAllocation(Job* job, double starttime,double runtime);
  virtual void allocateJob(Job* job, AnalogicalJobAllocation* allocation);
  virtual void releaseJobResources(Job* job); //releases the jobs consumed resources and updates the paraver stuff    
	
  void updateTerminationEvents(Job* scheduler); //this function checks that all the starts times and end simulation times for each of the jobs in the system are coherent with their penalized runtime , the events start and end are only generated by those jobs already scheduled. 
  void freeAllocation(AnalogicalJobAllocation* allocationForCheckingReq); //this is related memory management , free all the memory used by the allocation 
  double thresshold; /**< This indicates the maximum threaschold allowed when finding out the allocation with the findLessConsumeThreshold Experiment */
  double alternativeThreshold; /**< Indicates the alternative threshold that can be used when the base threshold of the less consume threshold can not be satisfied.*/
};


}

#endif
